---
# Tareas para desplegar la aplicaciÃ³n con Helm y configurar HPA
- name: Add Helm repository for metrics-server (if needed)
  command: >
    helm repo add metrics-server https://kubernetes-sigs.github.io/metrics-server/
  register: repo_result
  failed_when:
    - repo_result.rc != 0
    - "'already exists' not in repo_result.stderr"
  changed_when: repo_result.rc == 0

- name: Update Helm repositories
  command: helm repo update
  changed_when: false

- name: Install metrics-server for HPA
  command: >
    helm upgrade --install metrics-server metrics-server/metrics-server
    --namespace kube-system
    --set args[0]="--kubelet-insecure-tls"
    --set args[1]="--kubelet-preferred-address-types=InternalIP"
  register: metrics_result
  changed_when: "'has been upgraded' in metrics_result.stdout or 'has been installed' in metrics_result.stdout"

- name: Wait for metrics-server to be ready
  command: kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=metrics-server -n kube-system --timeout=180s
  changed_when: false

- name: Create values override file for GCP deployment
  copy:
    dest: /tmp/values-gcp-autoscaling.yaml
    content: |
      replicaCount:
        backend: {{ autoscaling.backend.min_replicas }}
        frontend: {{ autoscaling.frontend.min_replicas }}
        postgres: 1
      
      image:
        backend:
          repository: {{ docker_registry }}/todoapp-backend
          pullPolicy: Always
          tag: "{{ image_tag }}"
        frontend:
          repository: {{ docker_registry }}/todoapp-frontend
          pullPolicy: Always
          tag: "{{ image_tag }}"
        postgres:
          repository: postgres
          pullPolicy: IfNotPresent
          tag: "15-alpine"
      
      service:
        backend:
          type: ClusterIP
          port: 5000
        frontend:
          type: LoadBalancer
          port: 3000
        postgres:
          type: ClusterIP
          port: 5432
      
      resources:
        backend:
          limits:
            cpu: 500m
            memory: 512Mi
          requests:
            cpu: 200m
            memory: 256Mi
        frontend:
          limits:
            cpu: 300m
            memory: 384Mi
          requests:
            cpu: 100m
            memory: 128Mi
        postgres:
          limits:
            cpu: 1000m
            memory: 1Gi
          requests:
            cpu: 500m
            memory: 512Mi
      
      autoscaling:
        enabled: true
        backend:
          minReplicas: {{ autoscaling.backend.min_replicas }}
          maxReplicas: {{ autoscaling.backend.max_replicas }}
          targetCPUUtilizationPercentage: {{ autoscaling.backend.target_cpu_utilization }}
          targetMemoryUtilizationPercentage: {{ autoscaling.backend.target_memory_utilization }}
        frontend:
          minReplicas: {{ autoscaling.frontend.min_replicas }}
          maxReplicas: {{ autoscaling.frontend.max_replicas }}
          targetCPUUtilizationPercentage: {{ autoscaling.frontend.target_cpu_utilization }}
          targetMemoryUtilizationPercentage: {{ autoscaling.frontend.target_memory_utilization }}
      
      postgresql:
        database: tasksdb
        username: postgres
        password: postgres

- name: Deploy TodoApp using Helm
  command: >
    helm upgrade --install {{ helm_release_name }}
    {{ helm_chart_path }}
    --namespace {{ app_namespace }}
    --values /tmp/values-gcp-autoscaling.yaml
    --wait
    --timeout 10m
  args:
    chdir: "{{ playbook_dir }}/.."
  register: helm_result
  changed_when: "'has been upgraded' in helm_result.stdout or 'has been installed' in helm_result.stdout"

- name: Wait for backend deployment to be ready
  command: >
    kubectl wait --for=condition=available deployment/{{ helm_release_name }}-backend
    -n {{ app_namespace }}
    --timeout=300s
  changed_when: false

- name: Wait for frontend deployment to be ready
  command: >
    kubectl wait --for=condition=available deployment/{{ helm_release_name }}-frontend
    -n {{ app_namespace }}
    --timeout=300s
  changed_when: false

- name: Get LoadBalancer external IP
  shell: |
    kubectl get svc {{ helm_release_name }}-frontend -n {{ app_namespace }} -o jsonpath='{.status.loadBalancer.ingress[0].ip}'
  register: external_ip
  until: external_ip.stdout != ""
  retries: 20
  delay: 15
  changed_when: false

- name: Display application access information
  debug:
    msg:
      - "Application deployed successfully!"
      - "Frontend URL: http://{{ external_ip.stdout }}:3000"
      - "Backend API: http://{{ external_ip.stdout }}:5000"
